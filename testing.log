Running ExUnit with seed: 224505, max_cases: 1


GorillaStream.Compression.Encoder.BitPackingTest [test/gorilla_stream/compression/encoder/bit_packing_test.exs]
  * test unpack/1 round-trip packing and unpacking preserves data (TODO: fix data format mismatch) [L#344]  * test unpack/1 round-trip packing and unpacking preserves data (TODO: fix data format mismatch) (skipped) [L#344]
  * test pack/2 handles empty timestamp and value data [L#6]  * test pack/2 handles empty timestamp and value data (7.4ms) [L#6]
  * test pack/2 first delta handling for different scenarios [L#276]  * test pack/2 first delta handling for different scenarios (0.00ms) [L#276]
  * test pack/2 metadata contains all required fields [L#238]  * test pack/2 metadata contains all required fields (0.00ms) [L#238]
  * test unpack/1 unpacks empty data correctly [L#310]  * test unpack/1 unpacks empty data correctly (0.00ms) [L#310]
  * test pack/2 handles mismatched counts between timestamps and values [L#59]  * test pack/2 handles mismatched counts between timestamps and values (11.4ms) [L#59]
  * test pack/2 creates proper header format with all required fields [L#88]  * test pack/2 creates proper header format with all required fields (0.00ms) [L#88]
  * test pack/2 handles complex bit patterns correctly [L#258]  * test pack/2 handles complex bit patterns correctly (0.00ms) [L#258]
  * test pack/2 handles large datasets efficiently [L#215]  * test pack/2 handles large datasets efficiently (0.00ms) [L#215]
  * test pack/2 handles various data sizes efficiently [L#119]  * test pack/2 handles various data sizes efficiently (0.00ms) [L#119]
  * test pack/2 packs single data point correctly [L#16]  * test pack/2 packs single data point correctly (0.00ms) [L#16]
  * test pack/2 packs two data points with proper header [L#38]  * test pack/2 packs two data points with proper header (0.00ms) [L#38]
  * test unpack/1 handles insufficient data for declared bitstream lengths [L#384]  * test unpack/1 handles insufficient data for declared bitstream lengths (0.00ms) [L#384]
  * test pack/2 pads bits to byte boundary correctly [L#68]  * test pack/2 pads bits to byte boundary correctly (0.00ms) [L#68]
  * test pack/2 bit length calculations are accurate [L#147]  * test pack/2 bit length calculations are accurate (0.00ms) [L#147]
  * test unpack/1 unpacks single data point correctly [L#318]  * test unpack/1 unpacks single data point correctly (0.00ms) [L#318]
  * test unpack/1 handles corrupted header gracefully [L#373]  * test unpack/1 handles corrupted header gracefully (0.00ms) [L#373]
  * test pack/2 preserves first timestamp and value in header [L#186]  * test pack/2 preserves first timestamp and value in header (0.00ms) [L#186]
  * test pack/2 handles edge case with zero-length bitstreams after header [L#175]  * test pack/2 handles edge case with zero-length bitstreams after header (0.00ms) [L#175]

GorillaStream.Compression.GorillaCompressionTest [test/gorilla_stream/compression/gorilla_compression_test.exs]
  * test compress/2 returns non-empty compressed data [L#130]  * test compress/2 returns non-empty compressed data (10.8ms) [L#130]
  * doctest GorillaStream.Compression.Gorilla.compress/2 (1) [L#3]  * doctest GorillaStream.Compression.Gorilla.compress/2 (1) (0.01ms) [L#3]
  * test original and decompressed streams are identical [L#136]  * test original and decompressed streams are identical (16.3ms) [L#136]
  * test decompress/2 handles negative values correctly [L#92]  * test decompress/2 handles negative values correctly (0.02ms) [L#92]
  * test compress/2 handles negative values correctly [L#78]  * test compress/2 handles negative values correctly (0.02ms) [L#78]
  * test validate_stream/1 rejects invalid streams [L#151]  * test validate_stream/1 rejects invalid streams (0.00ms) [L#151]
  * test compress/2 handles empty stream correctly [L#99]  * test compress/2 handles empty stream correctly (0.00ms) [L#99]
  * doctest GorillaStream.Compression.Gorilla.validate_stream/1 (4) [L#3]  * doctest GorillaStream.Compression.Gorilla.validate_stream/1 (4) (0.00ms) [L#3]
  * test compress/2 returns compressed data with zlib compression disabled [L#33]  * test compress/2 returns compressed data with zlib compression disabled (0.03ms) [L#33]
  * test decompress/2 handles large values correctly [L#85]  * test decompress/2 handles large values correctly (0.02ms) [L#85]
  * test decompress/2 returns decoder error for invalid gorilla data after zlib [L#177]  * test decompress/2 returns decoder error for invalid gorilla data after zlib (0.04ms) [L#177]
  * test compress/2 handles large values correctly [L#71]  * test compress/2 handles large values correctly (0.01ms) [L#71]
  * test decompress/2 returns zlib error for malformed zlib data [L#167]  * test decompress/2 returns zlib error for malformed zlib data (8.8ms) [L#167]
  * test compress/2 returns compressed data with zlib compression enabled [L#40]  * test compress/2 returns compressed data with zlib compression enabled (0.05ms) [L#40]
  * test compress/2 returns error for invalid stream format [L#109]  * test compress/2 returns error for invalid stream format (0.00ms) [L#109]
  * doctest GorillaStream.Compression.Gorilla.compress/2 (2) [L#3]  * doctest GorillaStream.Compression.Gorilla.compress/2 (2) (0.01ms) [L#3]
  * doctest GorillaStream.Compression.Gorilla.decompress/2 (3) [L#3]  * doctest GorillaStream.Compression.Gorilla.decompress/2 (3) (0.01ms) [L#3]
  * test compress/2 returns error for invalid data type [L#122]  * test compress/2 returns error for invalid data type (0.00ms) [L#122]
  * doctest GorillaStream.Compression.Gorilla.validate_stream/1 (5) [L#3]  * doctest GorillaStream.Compression.Gorilla.validate_stream/1 (5) (0.00ms) [L#3]
  * test zlib compression reduces data size [L#47]  * test zlib compression reduces data size (0.01ms) [L#47]
  * test validate_stream/1 accepts valid streams [L#143]  * test validate_stream/1 accepts valid streams (0.00ms) [L#143]
  * test decompress/2 handles empty stream correctly [L#104]  * test decompress/2 handles empty stream correctly (0.00ms) [L#104]
  * test decompress/2 returns error for invalid compressed data [L#117]  * test decompress/2 returns error for invalid compressed data (0.03ms) [L#117]
  * test decompress/2 returns original stream with zlib compression enabled [L#64]  * test decompress/2 returns original stream with zlib compression enabled (0.09ms) [L#64]
  * test decompress/2 returns original stream with zlib compression disabled [L#57]  * test decompress/2 returns original stream with zlib compression disabled (0.01ms) [L#57]

GorillaStream.Compression.Encoder.DeltaEncodingTest [test/gorilla_stream/compression/encoder/delta_encoding_test.exs]
  * test first delta encoding edge cases encodes small positive first delta efficiently [L#222]  * test first delta encoding edge cases encodes small positive first delta efficiently (0.00ms) [L#222]
  * test delta-of-delta encoding patterns handles boundary values for delta-of-delta encoding [L#297]  * test delta-of-delta encoding patterns handles boundary values for delta-of-delta encoding (0.00ms) [L#297]
  * test encode/1 handles empty list [L#6]  * test encode/1 handles empty list (0.00ms) [L#6]
  * test first delta encoding edge cases encodes small negative first delta efficiently [L#232]  * test first delta encoding edge cases encodes small negative first delta efficiently (0.00ms) [L#232]
  * test encode/1 encodes timestamps in ascending order correctly [L#150]  * test encode/1 encodes timestamps in ascending order correctly (0.00ms) [L#150]
  * test encode/1 handles edge case with maximum timestamp values [L#128]  * test encode/1 handles edge case with maximum timestamp values (0.00ms) [L#128]
  * test first delta encoding edge cases encodes large first delta with 12 bits [L#252]  * test first delta encoding edge cases encodes large first delta with 12 bits (0.00ms) [L#252]
  * test encode/1 handles rapid timestamp changes [L#161]  * test encode/1 handles rapid timestamp changes (0.00ms) [L#161]
  * test encode/1 handles regular time series with consistent intervals [L#33]  * test encode/1 handles regular time series with consistent intervals (0.00ms) [L#33]
  * test encode/1 handles zero delta (repeated timestamps) [L#56]  * test encode/1 handles zero delta (repeated timestamps) (0.00ms) [L#56]
  * test delta-of-delta encoding patterns encodes small delta-of-delta efficiently [L#285]  * test delta-of-delta encoding patterns encodes small delta-of-delta efficiently (0.00ms) [L#285]
  * test encode/1 handles alternating pattern creating variable delta-of-deltas [L#139]  * test encode/1 handles alternating pattern creating variable delta-of-deltas (0.00ms) [L#139]
  * test delta-of-delta encoding patterns encodes zero delta-of-delta with single bit [L#276]  * test delta-of-delta encoding patterns encodes zero delta-of-delta with single bit (0.00ms) [L#276]
  * test encode/1 handles boundary conditions for delta-of-delta encoding [L#105]  * test encode/1 handles boundary conditions for delta-of-delta encoding (0.00ms) [L#105]
  * test first delta encoding edge cases encodes very large first delta with 32 bits [L#263]  * test first delta encoding edge cases encodes very large first delta with 32 bits (0.00ms) [L#263]
  * test encode/1 handles negative deltas (decreasing timestamps) [L#65]  * test encode/1 handles negative deltas (decreasing timestamps) (0.00ms) [L#65]
  * test encode/1 bit size scales reasonably with input size [L#184]  * test encode/1 bit size scales reasonably with input size (0.01ms) [L#184]
  * test encode/1 handles single timestamp [L#10]  * test encode/1 handles single timestamp (0.00ms) [L#10]
  * test encode/1 handles two timestamps with regular delta [L#22]  * test encode/1 handles two timestamps with regular delta (0.02ms) [L#22]
  * test first delta encoding edge cases encodes zero first delta [L#211]  * test first delta encoding edge cases encodes zero first delta (0.00ms) [L#211]
  * test encode/1 handles irregular intervals [L#45]  * test encode/1 handles irregular intervals (0.00ms) [L#45]
  * test encode/1 handles large positive deltas [L#74]  * test encode/1 handles large positive deltas (0.00ms) [L#74]
  * test first delta encoding edge cases encodes medium first delta with 9 bits [L#242]  * test first delta encoding edge cases encodes medium first delta with 9 bits (0.00ms) [L#242]
  * test encode/1 produces consistent metadata format [L#172]  * test encode/1 produces consistent metadata format (0.00ms) [L#172]
  * test encode/1 handles mixed positive and negative delta patterns [L#198]  * test encode/1 handles mixed positive and negative delta patterns (0.00ms) [L#198]
  * test encode/1 handles very large deltas requiring 32-bit encoding [L#94]  * test encode/1 handles very large deltas requiring 32-bit encoding (0.00ms) [L#94]
  * test encode/1 handles large negative deltas [L#85]  * test encode/1 handles large negative deltas (0.00ms) [L#85]

GorillaStream.Compression.Decoder.MetadataTest [test/gorilla_stream/compression/decoder/metadata_test.exs]
  * test get_header_info/1 rejects non-binary input [L#438]  * test get_header_info/1 rejects non-binary input (0.00ms) [L#438]
  * test estimate_original_size/1 handles non-map input [L#483]  * test estimate_original_size/1 handles non-map input (0.00ms) [L#483]
  * test extract_metadata/1 extracts valid metadata from properly formatted binary [L#9]  * test extract_metadata/1 extracts valid metadata from properly formatted binary (0.00ms) [L#9]
  * test has_valid_header?/1 returns true for valid header [L#444]  * test has_valid_header?/1 returns true for valid header (0.00ms) [L#444]
  * test calculate_efficiency_metrics/1 handles zero original size [L#507]  * test calculate_efficiency_metrics/1 handles zero original size (0.00ms) [L#507]
  * test validate_metadata_header/1 rejects unsupported version [L#362]  * test validate_metadata_header/1 rejects unsupported version (0.00ms) [L#362]
  * test validate_metadata_header/1 rejects binary too small [L#343]  * test validate_metadata_header/1 rejects binary too small (0.00ms) [L#343]
  * test has_valid_header?/1 returns false for non-binary input [L#456]  * test has_valid_header?/1 returns false for non-binary input (0.00ms) [L#456]
  * test validate_metadata_header/1 rejects invalid header length [L#377]  * test validate_metadata_header/1 rejects invalid header length (0.00ms) [L#377]
  * test extract_metadata/1 handles future version gracefully [L#107]  * test extract_metadata/1 handles future version gracefully (0.00ms) [L#107]
  * test extract_metadata/1 handles single data point (count = 1) [L#171]  * test extract_metadata/1 handles single data point (count = 1) (0.01ms) [L#171]
  * test estimate_original_size/1 handles missing count [L#477]  * test estimate_original_size/1 handles missing count (0.00ms) [L#477]
  * test validate_metadata_header/1 rejects invalid magic number [L#350]  * test validate_metadata_header/1 rejects invalid magic number (0.00ms) [L#350]
  * test estimate_original_size/1 handles zero count [L#471]  * test estimate_original_size/1 handles zero count (0.00ms) [L#471]
  * test validate_metadata_header/1 validates correct header format [L#337]  * test validate_metadata_header/1 validates correct header format (0.00ms) [L#337]
  * test calculate_efficiency_metrics/1 handles completely empty metadata [L#551]  * test calculate_efficiency_metrics/1 handles completely empty metadata (0.00ms) [L#551]
  * test calculate_efficiency_metrics/1 calculates comprehensive metrics [L#490]  * test calculate_efficiency_metrics/1 calculates comprehensive metrics (0.00ms) [L#490]
  * test estimate_original_size/1 calculates size for given count [L#464]  * test estimate_original_size/1 calculates size for given count (0.00ms) [L#464]
  * test extract_metadata/1 handles empty compressed data [L#210]  * test extract_metadata/1 handles empty compressed data (0.00ms) [L#210]
  * test get_header_info/1 extracts basic info from valid header [L#397]  * test get_header_info/1 extracts basic info from valid header (0.00ms) [L#397]
  * test calculate_efficiency_metrics/1 handles extreme compression ratios [L#564]  * test calculate_efficiency_metrics/1 handles extreme compression ratios (0.00ms) [L#564]
  * test calculate_efficiency_metrics/1 uses estimated original size when missing [L#535]  * test calculate_efficiency_metrics/1 uses estimated original size when missing (0.00ms) [L#535]
  * test calculate_efficiency_metrics/1 handles zero count [L#521]  * test calculate_efficiency_metrics/1 handles zero count (0.00ms) [L#521]
  * test extract_metadata/1 handles binary too small for metadata header [L#67]  * test extract_metadata/1 handles binary too small for metadata header (0.00ms) [L#67]
  * test extract_metadata/1 handles invalid magic number [L#76]  * test extract_metadata/1 handles invalid magic number (0.00ms) [L#76]
  * test get_header_info/1 returns error for invalid header [L#431]  * test get_header_info/1 returns error for invalid header (0.00ms) [L#431]
  * test extract_metadata/1 handles checksum mismatch with warning flag [L#138]  * test extract_metadata/1 handles checksum mismatch with warning flag (0.00ms) [L#138]
  * test extract_metadata/1 handles non-binary input [L#250]  * test extract_metadata/1 handles non-binary input (0.00ms) [L#250]
  * test has_valid_header?/1 returns false for invalid header [L#450]  * test has_valid_header?/1 returns false for invalid header (0.00ms) [L#450]
  * test validate_metadata_header/1 rejects non-binary input [L#389]  * test validate_metadata_header/1 rejects non-binary input (0.00ms) [L#389]
  * test get_header_info/1 handles zero original size [L#411]  * test get_header_info/1 handles zero original size (0.00ms) [L#411]
  * test extract_metadata/1 handles extreme values correctly [L#290]  * test extract_metadata/1 handles extreme values correctly (0.00ms) [L#290]
  * test extract_metadata/1 handles binary smaller than compressed_size [L#257]  * test extract_metadata/1 handles binary smaller than compressed_size (0.00ms) [L#257]

GorillaStreamTest [test/gorilla_stream_test.exs]
  * test comprehensive edge cases for GorillaStream coverage round-trip consistency across multiple iterations [L#263]  * test comprehensive edge cases for GorillaStream coverage round-trip consistency across multiple iterations (0.02ms) [L#263]
  * doctest GorillaStream.compress/2 (1) [L#3]  * doctest GorillaStream.compress/2 (1) (0.00ms) [L#3]
  * test comprehensive edge cases for GorillaStream coverage error handling for malformed compressed data [L#284]  * test comprehensive edge cases for GorillaStream coverage error handling for malformed compressed data (0.00ms) [L#284]
  * test comprehensive edge cases for GorillaStream coverage handles large datasets efficiently [L#173]  * test comprehensive edge cases for GorillaStream coverage handles large datasets efficiently (0.08ms) [L#173]
  * test comprehensive edge cases for GorillaStream coverage handles float values correctly [L#131]  * test comprehensive edge cases for GorillaStream coverage handles float values correctly (0.00ms) [L#131]
  * test comprehensive edge cases for GorillaStream coverage handles zero values and signed zero [L#190]  * test comprehensive edge cases for GorillaStream coverage handles zero values and signed zero (0.00ms) [L#190]
  * test greets the world [L#5]  * test greets the world (0.00ms) [L#5]
  * test comprehensive edge cases for GorillaStream coverage handles single data point compression and decompression [L#47]  * test comprehensive edge cases for GorillaStream coverage handles single data point compression and decompression (0.00ms) [L#47]
  * test comprehensive edge cases for GorillaStream coverage compression with zlib enabled vs disabled produces different sizes [L#143]  * test comprehensive edge cases for GorillaStream coverage compression with zlib enabled vs disabled produces different sizes (0.03ms) [L#143]
  * test comprehensive edge cases for GorillaStream coverage handles irregular timestamp intervals [L#113]  * test comprehensive edge cases for GorillaStream coverage handles irregular timestamp intervals (0.00ms) [L#113]
  * test comprehensive edge cases for GorillaStream coverage handles identical consecutive values efficiently [L#55]  * test comprehensive edge cases for GorillaStream coverage handles identical consecutive values efficiently (0.00ms) [L#55]
  * test comprehensive edge cases for GorillaStream coverage handles gradual value changes [L#223]  * test comprehensive edge cases for GorillaStream coverage handles gradual value changes (0.01ms) [L#223]
  * doctest GorillaStream.decompress/2 (2) [L#3]  * doctest GorillaStream.decompress/2 (2) (0.00ms) [L#3]
  * doctest GorillaStream.hello/0 (3) [L#3]  * doctest GorillaStream.hello/0 (3) (0.00ms) [L#3]
  * test comprehensive edge cases for GorillaStream coverage handles high precision floating point values [L#251]  * test comprehensive edge cases for GorillaStream coverage handles high precision floating point values (0.00ms) [L#251]
  * test Gorilla compression library works correctly [L#10]  * test Gorilla compression library works correctly (0.02ms) [L#10]
  * test comprehensive edge cases for GorillaStream coverage handles large timestamp values [L#71]  * test comprehensive edge cases for GorillaStream coverage handles large timestamp values (0.00ms) [L#71]
  * test comprehensive edge cases for GorillaStream coverage handles alternating patterns [L#207]  * test comprehensive edge cases for GorillaStream coverage handles alternating patterns (0.04ms) [L#207]
  * test comprehensive edge cases for GorillaStream coverage handles step function patterns [L#234]  * test comprehensive edge cases for GorillaStream coverage handles step function patterns (0.01ms) [L#234]
  * test comprehensive edge cases for GorillaStream coverage handles negative values and timestamps [L#101]  * test comprehensive edge cases for GorillaStream coverage handles negative values and timestamps (0.02ms) [L#101]
  * test comprehensive edge cases for GorillaStream coverage handles extreme float values [L#85]  * test comprehensive edge cases for GorillaStream coverage handles extreme float values (0.01ms) [L#85]

GorillaStream.Compression.Decoder.DeltaDecodingTest [test/gorilla_stream/compression/decoder/delta_decoding_test.exs]
  * test validate_bitstream/2 validates correct bitstream [L#541]  * test validate_bitstream/2 validates correct bitstream (0.00ms) [L#541]
  * test error conditions and edge cases decode/2 handles all first delta encoding formats [L#597]  * test error conditions and edge cases decode/2 handles all first delta encoding formats (0.00ms) [L#597]
  * test decode/2 handles empty bitstream with count 0 [L#6]  * test decode/2 handles empty bitstream with count 0 (0.00ms) [L#6]
  * test validate_bitstream/2 rejects invalid bitstream [L#546]  * test validate_bitstream/2 rejects invalid bitstream (0.00ms) [L#546]
  * test error conditions and edge cases decode/2 handles reconstruction with empty delta-of-deltas list [L#651]  * test error conditions and edge cases decode/2 handles reconstruction with empty delta-of-deltas list (0.00ms) [L#651]
  * test decode/2 returns error for invalid input types [L#380]  * test decode/2 returns error for invalid input types (0.01ms) [L#380]

  1) test decode/2 returns error for invalid input types (GorillaStream.Compression.Decoder.DeltaDecodingTest)
     test/gorilla_stream/compression/decoder/delta_decoding_test.exs:380
     match (=) failed
     code:  assert {:error, "Invalid input - expected bitstring and metadata"} =
              DeltaDecoding.decode("not bitstring", %{})
     left:  {:error, "Invalid input - expected bitstring and metadata"}
     right: {:ok, []}
     stacktrace:
       test/gorilla_stream/compression/decoder/delta_decoding_test.exs:381: (test)

  * test decode/2 handles delta-of-delta requiring 9-bit encoding [L#309]  * test decode/2 handles delta-of-delta requiring 9-bit encoding (0.00ms) [L#309]
  * test get_bitstream_info/2 returns info for empty bitstream [L#559]  * test get_bitstream_info/2 returns info for empty bitstream (0.00ms) [L#559]

  2) test get_bitstream_info/2 returns info for empty bitstream (GorillaStream.Compression.Decoder.DeltaDecodingTest)
     test/gorilla_stream/compression/decoder/delta_decoding_test.exs:559
     match (=) failed
     code:  assert {:ok, info} = DeltaDecoding.get_bitstream_info(<<>>, %{count: 0})
     left:  {:ok, info}
     right: {:error, "Invalid input"}
     stacktrace:
       test/gorilla_stream/compression/decoder/delta_decoding_test.exs:560: (test)

  * test decode/2 handles insufficient data gracefully [L#388]  * test decode/2 handles insufficient data gracefully (0.00ms) [L#388]
  * test decode/2 decodes regular time series with zero delta-of-deltas [L#34]  * test decode/2 decodes regular time series with zero delta-of-deltas (0.00ms) [L#34]
  * test decode/2 decodes negative deltas correctly [L#109]  * test decode/2 decodes negative deltas correctly (0.00ms) [L#109]
  * test get_bitstream_info/2 handles invalid input gracefully [L#590]  * test get_bitstream_info/2 handles invalid input gracefully (0.00ms) [L#590]

  3) test get_bitstream_info/2 handles invalid input gracefully (GorillaStream.Compression.Decoder.DeltaDecodingTest)
     test/gorilla_stream/compression/decoder/delta_decoding_test.exs:590
     match (=) failed
     code:  assert {:error, "Invalid input"} = DeltaDecoding.get_bitstream_info("not bitstring", %{})
     left:  {:error, "Invalid input"}
     right: {:ok, %{count: 0, first_timestamp: nil, estimated_range: nil}}
     stacktrace:
       test/gorilla_stream/compression/decoder/delta_decoding_test.exs:591: (test)

  * test decode/2 handles negative delta-of-deltas [L#345]  * test decode/2 handles negative delta-of-deltas (0.00ms) [L#345]
  * test get_bitstream_info/2 returns info for multiple timestamps [L#576]  * test get_bitstream_info/2 returns info for multiple timestamps (0.00ms) [L#576]
  * test decode/2 handles boundary values for delta-of-delta encoding [L#274]  * test decode/2 handles boundary values for delta-of-delta encoding (0.00ms) [L#274]
  * test error conditions and edge cases validate_bitstream/2 handles count mismatch [L#680]  * test error conditions and edge cases validate_bitstream/2 handles count mismatch (0.00ms) [L#680]
  * test error conditions and edge cases decode/2 handles all delta-of-delta encoding formats [L#630]  * test error conditions and edge cases decode/2 handles all delta-of-delta encoding formats (0.00ms) [L#630]
  * test get_bitstream_info/2 returns info for single timestamp [L#565]  * test get_bitstream_info/2 returns info for single timestamp (0.00ms) [L#565]
  * test decode/2 decodes zero first delta [L#141]  * test decode/2 decodes zero first delta (0.00ms) [L#141]
  * test decode/2 handles edge case with maximum timestamp values [L#420]  * test decode/2 handles edge case with maximum timestamp values (0.00ms) [L#420]
  * test error conditions and edge cases get_bitstream_info/2 with non-map metadata [L#672]  * test error conditions and edge cases get_bitstream_info/2 with non-map metadata (0.00ms) [L#672]
  * test error conditions and edge cases validate_bitstream/2 with non-integer expected_count [L#664]  * test error conditions and edge cases validate_bitstream/2 with non-integer expected_count (0.00ms) [L#664]
  * test decode/2 decodes single timestamp correctly [L#10]  * test decode/2 decodes single timestamp correctly (0.00ms) [L#10]
  * test decode/2 decodes two timestamps with simple delta [L#18]  * test decode/2 decodes two timestamps with simple delta (0.00ms) [L#18]
  * test decode/2 handles alternating delta pattern efficiently [L#493]  * test decode/2 handles alternating delta pattern efficiently (0.01ms) [L#493]
  * test decode/2 decodes timestamps with varying delta-of-deltas [L#69]  * test decode/2 decodes timestamps with varying delta-of-deltas (0.00ms) [L#69]
  * test decode/2 decodes large deltas requiring 9-bit encoding [L#171]  * test decode/2 decodes large deltas requiring 9-bit encoding (0.00ms) [L#171]
  * test validate_bitstream/2 rejects non-bitstring input [L#552]  * test validate_bitstream/2 rejects non-bitstring input (0.00ms) [L#552]

  4) test validate_bitstream/2 rejects non-bitstring input (GorillaStream.Compression.Decoder.DeltaDecodingTest)
     test/gorilla_stream/compression/decoder/delta_decoding_test.exs:552
     match (=) failed
     code:  assert {:error, "Invalid input - expected bitstring"} =
              DeltaDecoding.validate_bitstream("not bitstring", 2)
     left:  {:error, "Invalid input - expected bitstring"}
     right: :ok
     stacktrace:
       test/gorilla_stream/compression/decoder/delta_decoding_test.exs:553: (test)

  * test decode/2 handles corrupted delta-of-delta data [L#397]  * test decode/2 handles corrupted delta-of-delta data (0.00ms) [L#397]
  * test decode/2 reconstructs complex timestamp pattern correctly [L#447]  * test decode/2 reconstructs complex timestamp pattern correctly (0.00ms) [L#447]
  * test decode/2 decodes maximum deltas requiring 32-bit encoding [L#240]  * test decode/2 decodes maximum deltas requiring 32-bit encoding (0.00ms) [L#240]
  * test decode/2 decodes very large deltas requiring 12-bit encoding [L#206]  * test decode/2 decodes very large deltas requiring 12-bit encoding (0.00ms) [L#206]

GorillaStream.Compression.Encoder.MetadataTest [test/gorilla_stream/compression/encoder/metadata_test.exs]
  * test validate_metadata_header/1 rejects non-binary input [L#335]  * test validate_metadata_header/1 rejects non-binary input (0.00ms) [L#335]
  * test integration with actual compression pipeline handles edge case with maximum values [L#446]  * test integration with actual compression pipeline handles edge case with maximum values (0.02ms) [L#446]
  * test add_metadata/2 adds comprehensive metadata to packed data [L#9]  * test add_metadata/2 adds comprehensive metadata to packed data (0.00ms) [L#9]
  * test get_header_info/1 extracts basic info from valid header [L#343]  * test get_header_info/1 extracts basic info from valid header (0.00ms) [L#343]
  * test add_metadata/2 handles non-map metadata by creating minimal metadata [L#266]  * test add_metadata/2 handles non-map metadata by creating minimal metadata (0.00ms) [L#266]
  * test add_metadata/2 includes creation timestamp in reasonable range [L#245]  * test add_metadata/2 includes creation timestamp in reasonable range (0.00ms) [L#245]
  * test get_header_info/1 returns error for invalid header [L#377]  * test get_header_info/1 returns error for invalid header (0.00ms) [L#377]
  * test validate_metadata_header/1 validates correct header format [L#284]  * test validate_metadata_header/1 validates correct header format (0.00ms) [L#284]
  * test add_metadata/2 handles empty packed data [L#79]  * test add_metadata/2 handles empty packed data (0.00ms) [L#79]
  * test add_metadata/2 calculates checksum correctly [L#142]  * test add_metadata/2 calculates checksum correctly (0.00ms) [L#142]
  * test integration with actual compression pipeline round-trip metadata consistency [L#412]  * test integration with actual compression pipeline round-trip metadata consistency (0.00ms) [L#412]
  * test add_metadata/2 returns error for non-binary packed data [L#260]  * test add_metadata/2 returns error for non-binary packed data (0.00ms) [L#260]
  * test get_header_info/1 calculates compression ratio correctly [L#388]  * test get_header_info/1 calculates compression ratio correctly (0.00ms) [L#388]
  * test add_metadata/2 handles zero count for compression ratio [L#230]  * test add_metadata/2 handles zero count for compression ratio (0.00ms) [L#230]
  * test integration with actual compression pipeline metadata size calculation is consistent [L#473]  * test integration with actual compression pipeline metadata size calculation is consistent (0.00ms) [L#473]
  * test get_header_info/1 rejects non-binary input [L#384]  * test get_header_info/1 rejects non-binary input (0.00ms) [L#384]
  * test add_metadata/2 handles float values correctly [L#156]  * test add_metadata/2 handles float values correctly (0.00ms) [L#156]
  * test validate_metadata_header/1 rejects invalid magic number [L#297]  * test validate_metadata_header/1 rejects invalid magic number (0.00ms) [L#297]
  * test add_metadata/2 handles metadata with missing optional fields [L#41]  * test add_metadata/2 handles metadata with missing optional fields (0.00ms) [L#41]
  * test add_metadata/2 creates minimal header when no metadata provided [L#63]  * test add_metadata/2 creates minimal header when no metadata provided (0.00ms) [L#63]
  * test validate_metadata_header/1 rejects invalid header length [L#323]  * test validate_metadata_header/1 rejects invalid header length (0.00ms) [L#323]
  * test add_metadata/2 handles large datasets with extreme values [L#102]  * test add_metadata/2 handles large datasets with extreme values (0.01ms) [L#102]
  * test add_metadata/2 handles integer values in value_metadata [L#175]  * test add_metadata/2 handles integer values in value_metadata (0.00ms) [L#175]
  * test get_header_info/1 handles zero original size [L#357]  * test get_header_info/1 handles zero original size (0.00ms) [L#357]
  * test validate_metadata_header/1 rejects binary too small [L#290]  * test validate_metadata_header/1 rejects binary too small (0.00ms) [L#290]
  * test validate_metadata_header/1 rejects unsupported version [L#309]  * test validate_metadata_header/1 rejects unsupported version (0.00ms) [L#309]
  * test add_metadata/2 calculates compression ratio correctly [L#213]  * test add_metadata/2 calculates compression ratio correctly (0.02ms) [L#213]
  * test add_metadata/2 handles invalid first_value gracefully [L#194]  * test add_metadata/2 handles invalid first_value gracefully (0.00ms) [L#194]

GorillaStream.Compression.Gorilla.EncoderTest [test/gorilla_stream/compression/gorilla/encoder_test.exs]
  * test estimation logic coverage handles empty list for delta and xor difference calculation [L#497]  * test estimation logic coverage handles empty list for delta and xor difference calculation (0.00ms) [L#497]
  * test encode/1 rejects nil input [L#223]  * test encode/1 rejects nil input (0.00ms) [L#223]
  * test estimation logic coverage hits all branches of estimate_average_bits_per_delta_of_delta with negative values [L#474]  * test estimation logic coverage hits all branches of estimate_average_bits_per_delta_of_delta with negative values (0.00ms) [L#474]
  * test estimate_compression_ratio/1 estimates ratio for random-like data [L#297]  * test estimate_compression_ratio/1 estimates ratio for random-like data (0.00ms) [L#297]
  * test encode/1 handles empty list [L#6]  * test encode/1 handles empty list (0.00ms) [L#6]
  * test encode/1 handles floating point precision edge cases [L#228]  * test encode/1 handles floating point precision edge cases (0.01ms) [L#228]
  * test estimate_compression_ratio/1 handles data with integer values [L#326]  * test estimate_compression_ratio/1 handles data with integer values (0.00ms) [L#326]
  * test encode/1 rejects invalid data format - non-tuple [L#179]  * test encode/1 rejects invalid data format - non-tuple (0.00ms) [L#179]
  * test estimation logic coverage hits all branches of estimate_first_delta_bits [L#426]  * test estimation logic coverage hits all branches of estimate_first_delta_bits (0.00ms) [L#426]
  * test encode/1 encodes alternating timestamp patterns [L#146]  * test encode/1 encodes alternating timestamp patterns (0.00ms) [L#146]
  * test estimate_compression_ratio/1 estimates ratio for empty data [L#256]  * test estimate_compression_ratio/1 estimates ratio for empty data (0.00ms) [L#256]
  * test encode/1 rejects invalid data format - wrong tuple structure [L#186]  * test encode/1 rejects invalid data format - wrong tuple structure (0.00ms) [L#186]
  * test integration and pipeline tests memory efficiency with large datasets [L#625]  * test integration and pipeline tests memory efficiency with large datasets (0.6ms) [L#625]
  * test encode/1 encodes data with integer values (converts to float) [L#32]  * test encode/1 encodes data with integer values (converts to float) (0.00ms) [L#32]
  * test integration and pipeline tests compression effectiveness on realistic datasets [L#581]  * test integration and pipeline tests compression effectiveness on realistic datasets (0.06ms) [L#581]
  * test encode/1 encodes data with slowly changing values [L#59]  * test encode/1 encodes data with slowly changing values (0.00ms) [L#59]
  * test estimate_compression_ratio/1 estimates ratio for identical values [L#282]  * test estimate_compression_ratio/1 estimates ratio for identical values (0.00ms) [L#282]
  * test edge cases and robustness handles timestamp overflow scenarios [L#643]  * test edge cases and robustness handles timestamp overflow scenarios (0.00ms) [L#643]
  * test edge cases and robustness validates input data thoroughly [L#669]  * test edge cases and robustness validates input data thoroughly (0.00ms) [L#669]
  * test encode/1 handles edge case with maximum timestamp values [L#164]  * test encode/1 handles edge case with maximum timestamp values (0.00ms) [L#164]
  * test estimation logic coverage handles a complex mix of edge cases in estimation [L#507]  * test estimation logic coverage handles a complex mix of edge cases in estimation (0.00ms) [L#507]
  * test estimate_compression_ratio/1 hits all branches of estimation helpers with positive and negative deltas [L#379]  * test estimate_compression_ratio/1 hits all branches of estimation helpers with positive and negative deltas (0.00ms) [L#379]
  * test estimate_compression_ratio/1 estimates ratio for regularly spaced data [L#267]  * test estimate_compression_ratio/1 estimates ratio for regularly spaced data (0.00ms) [L#267]
  * test integration and pipeline tests encoding pipeline produces consistent output format [L#534]  * test integration and pipeline tests encoding pipeline produces consistent output format (0.00ms) [L#534]
  * test encode/1 encodes data with zero deltas (regular interval) [L#133]  * test encode/1 encodes data with zero deltas (regular interval) (0.00ms) [L#133]
  * test estimate_compression_ratio/1 rejects non-list input for estimation [L#361]  * test estimate_compression_ratio/1 rejects non-list input for estimation (0.00ms) [L#361]
  * test pipeline error handling returns error when value compression fails [L#734]  * test pipeline error handling returns error when value compression fails (0.01ms) [L#734]
  * test estimate_compression_ratio/1 estimates ratio for large dataset [L#312]  * test estimate_compression_ratio/1 estimates ratio for large dataset (0.01ms) [L#312]
  * test estimation logic coverage handles single element list for delta and xor calculation [L#502]  * test estimation logic coverage handles single element list for delta and xor calculation (0.00ms) [L#502]
  * test integration and pipeline tests error handling throughout pipeline [L#569]  * test integration and pipeline tests error handling throughout pipeline (0.00ms) [L#569]
  * test estimate_compression_ratio/1 handles single and two-point lists in estimation [L#408]  * test estimate_compression_ratio/1 handles single and two-point lists in estimation (0.00ms) [L#408]
  * test estimate_compression_ratio/1 estimates ratio for single data point [L#260]  * test estimate_compression_ratio/1 estimates ratio for single data point (0.00ms) [L#260]
  * test encode/1 encodes data with irregular timestamp intervals [L#73]  * test encode/1 encodes data with irregular timestamp intervals (0.00ms) [L#73]
  * test edge cases and robustness handles very small datasets [L#709]  * test edge cases and robustness handles very small datasets (0.00ms) [L#709]
  * test estimation logic coverage hits all branches of estimate_average_bits_per_delta_of_delta [L#450]  * test estimation logic coverage hits all branches of estimate_average_bits_per_delta_of_delta (0.00ms) [L#450]
  * test encode/1 rejects invalid value type [L#200]  * test encode/1 rejects invalid value type (0.00ms) [L#200]
  * test estimate_compression_ratio/1 handles estimation errors gracefully [L#366]  * test estimate_compression_ratio/1 handles estimation errors gracefully (0.00ms) [L#366]
  * test estimate_compression_ratio/1 rejects invalid data format in estimation [L#354]  * test estimate_compression_ratio/1 rejects invalid data format in estimation (0.00ms) [L#354]
  * test integration and pipeline tests handles various data patterns without errors [L#548]  * test integration and pipeline tests handles various data patterns without errors (0.03ms) [L#548]
  * test edge cases and robustness handles zero and negative timestamps [L#658]  * test edge cases and robustness handles zero and negative timestamps (0.00ms) [L#658]
  * test estimate_compression_ratio/1 estimates ratio for data with extreme timestamp gaps [L#338]  * test estimate_compression_ratio/1 estimates ratio for data with extreme timestamp gaps (0.00ms) [L#338]
  * test encode/1 encodes single data point [L#10]  * test encode/1 encodes single data point (0.00ms) [L#10]
  * test encode/1 encodes multiple data points with regular timestamps [L#17]  * test encode/1 encodes multiple data points with regular timestamps (0.00ms) [L#17]
  * test encode/1 rejects non-list input [L#218]  * test encode/1 rejects non-list input (0.00ms) [L#218]
  * test integration and pipeline tests handles mixed timestamp intervals [L#600]  * test integration and pipeline tests handles mixed timestamp intervals (0.01ms) [L#600]
  * test encode/1 encodes data with identical consecutive values efficiently [L#44]  * test encode/1 encodes data with identical consecutive values efficiently (0.00ms) [L#44]
  * test encode/1 encodes data with negative values [L#89]  * test encode/1 encodes data with negative values (0.00ms) [L#89]
  * test estimation logic coverage estimates ratio for exactly two data points [L#419]  * test estimation logic coverage estimates ratio for exactly two data points (0.00ms) [L#419]
  * test encode/1 encodes data with subnormal float values [L#240]  * test encode/1 encodes data with subnormal float values (0.00ms) [L#240]
  * test pipeline error handling returns error when timestamp encoding fails [L#723]  * test pipeline error handling returns error when timestamp encoding fails (0.01ms) [L#723]
  * test encode/1 rejects invalid timestamp type [L#193]  * test encode/1 rejects invalid timestamp type (0.00ms) [L#193]
  * test encode/1 rejects mixed valid and invalid data [L#207]  * test encode/1 rejects mixed valid and invalid data (0.01ms) [L#207]
  * test encode/1 encodes large datasets efficiently [L#115]  * test encode/1 encodes large datasets efficiently (0.1ms) [L#115]
  * test encode/1 encodes data with extreme float values [L#101]  * test encode/1 encodes data with extreme float values (0.00ms) [L#101]

GorillaStream.Compression.Decoder.BitUnpackingTest [test/gorilla_stream/compression/decoder/bit_unpacking_test.exs]
  * test round-trip consistency handles empty bitstreams in round-trip [L#340]  * test round-trip consistency handles empty bitstreams in round-trip (0.00ms) [L#340]
  * test get_packed_info/1 extracts info from valid packed data [L#428]  * test get_packed_info/1 extracts info from valid packed data (0.00ms) [L#428]
  * test unpack/1 unpacks empty data [L#10]  * test unpack/1 unpacks empty data (0.00ms) [L#10]
  * test round-trip consistency preserves exact bit patterns for various data patterns [L#356]  * test round-trip consistency preserves exact bit patterns for various data patterns (0.02ms) [L#356]
  * test get_packed_info/1 rejects non-binary input [L#453]  * test get_packed_info/1 rejects non-binary input (0.00ms) [L#453]
  * test error conditions and edge cases handles corrupted header data [L#207]  * test error conditions and edge cases handles corrupted header data (5.0ms) [L#207]
  * test error conditions and edge cases handles insufficient data for header [L#194]  * test error conditions and edge cases handles insufficient data for header (0.00ms) [L#194]
  * test validate_packed_data/1 validates empty packed data [L#398]  * test validate_packed_data/1 validates empty packed data (0.00ms) [L#398]
  * test error conditions and edge cases handles data with zero bit lengths [L#220]  * test error conditions and edge cases handles data with zero bit lengths (0.00ms) [L#220]
  * test unpack/1 unpacks multiple timestamps and values [L#55]  * test unpack/1 unpacks multiple timestamps and values (0.00ms) [L#55]
  * test unpack/1 unpacks data with negative values [L#93]  * test unpack/1 unpacks data with negative values (0.00ms) [L#93]
  * test validate_packed_data/1 handles corrupted data gracefully [L#415]  * test validate_packed_data/1 handles corrupted data gracefully (0.01ms) [L#415]
  * test error conditions and edge cases handles invalid input types [L#201]  * test error conditions and edge cases handles invalid input types (0.00ms) [L#201]
  * test estimate_unpacking_performance/1 handles corrupted data gracefully [L#498]  * test estimate_unpacking_performance/1 handles corrupted data gracefully (0.00ms) [L#498]
  * test validate_packed_data/1 rejects non-binary input [L#407]  * test validate_packed_data/1 rejects non-binary input (0.00ms) [L#407]
  * test unpack/1 unpacks high precision floating point values [L#176]  * test unpack/1 unpacks high precision floating point values (0.02ms) [L#176]
  * test estimate_unpacking_performance/1 handles empty data [L#488]  * test estimate_unpacking_performance/1 handles empty data (0.00ms) [L#488]
  * test get_packed_info/1 handles empty data [L#448]  * test get_packed_info/1 handles empty data (0.00ms) [L#448]
  * test performance and stress testing handles very large datasets efficiently [L#511]  * test performance and stress testing handles very large datasets efficiently (0.4ms) [L#511]
  * test validate_packed_data/1 handles insufficient data [L#402]  * test validate_packed_data/1 handles insufficient data (0.00ms) [L#402]
  * test unpack/1 unpacks data with zero values [L#109]  * test unpack/1 unpacks data with zero values (0.00ms) [L#109]
  * test error conditions and edge cases handles very large bit lengths [L#272]  * test error conditions and edge cases handles very large bit lengths (0.00ms) [L#272]
  * test estimate_unpacking_performance/1 rejects non-binary input [L#493]  * test estimate_unpacking_performance/1 rejects non-binary input (0.00ms) [L#493]
  * test estimate_unpacking_performance/1 estimates performance for typical data [L#471]  * test estimate_unpacking_performance/1 estimates performance for typical data (0.00ms) [L#471]
  * test get_packed_info/1 handles corrupted header gracefully [L#458]  * test get_packed_info/1 handles corrupted header gracefully (0.00ms) [L#458]
  * test unpack/1 unpacks single timestamp data [L#14]  * test unpack/1 unpacks single timestamp data (0.00ms) [L#14]
  * test unpack/1 unpacks two timestamp data [L#35]  * test unpack/1 unpacks two timestamp data (0.00ms) [L#35]
  * test round-trip consistency maintains bit-level consistency through pack/unpack cycle [L#321]  * test round-trip consistency maintains bit-level consistency through pack/unpack cycle (0.00ms) [L#321]
  * test unpack/1 unpacks data with large timestamps [L#76]  * test unpack/1 unpacks data with large timestamps (0.00ms) [L#76]
  * test unpack/1 unpacks data with identical values [L#125]  * test unpack/1 unpacks data with identical values (0.00ms) [L#125]
  * test performance and stress testing handles minimal datasets correctly [L#530]  * test performance and stress testing handles minimal datasets correctly (0.00ms) [L#530]
  * test validate_packed_data/1 validates correctly packed data [L#387]  * test validate_packed_data/1 validates correctly packed data (0.00ms) [L#387]
  * test error conditions and edge cases handles truncated bitstream data [L#244]  * test error conditions and edge cases handles truncated bitstream data (0.00ms) [L#244]
  * test error conditions and edge cases preserves metadata fields correctly [L#298]  * test error conditions and edge cases preserves metadata fields correctly (0.00ms) [L#298]
  * test unpack/1 unpacks large dataset [L#158]  * test unpack/1 unpacks large dataset (0.03ms) [L#158]
  * test unpack/1 unpacks data with varying timestamp deltas [L#141]  * test unpack/1 unpacks data with varying timestamp deltas (0.00ms) [L#141]

GorillaStream.Compression.Decoder.ValueDecompressionTest [test/gorilla_stream/compression/decoder/value_decompression_test.exs]
  * test decompress_and_validate/3 validates with expected count [L#388]  * test decompress_and_validate/3 validates with expected count (0.01ms) [L#388]
  * test error conditions handles empty bitstream with non-zero count [L#173]  * test error conditions handles empty bitstream with non-zero count (0.00ms) [L#173]
  * test decompress_and_validate/3 decompresses and validates basic data [L#373]  * test decompress_and_validate/3 decompresses and validates basic data (0.00ms) [L#373]
  * test get_bitstream_info/2 returns info for empty bitstream [L#228]  * test get_bitstream_info/2 returns info for empty bitstream (0.00ms) [L#228]
  * test decompress/2 decompresses empty bitstream with zero count [L#8]  * test decompress/2 decompresses empty bitstream with zero count (0.00ms) [L#8]
  * test error conditions handles malformed metadata [L#181]  * test error conditions handles malformed metadata (0.00ms) [L#181]
  * test get_bitstream_info/2 returns info for multiple values [L#243]  * test get_bitstream_info/2 returns info for multiple values (0.00ms) [L#243]
  * test decompress/2 decompresses large dataset [L#109]  * test decompress/2 decompresses large dataset (0.1ms) [L#109]
  * test compression efficiency scenarios handles poorly compressible data [L#351]  * test compression efficiency scenarios handles poorly compressible data (0.03ms) [L#351]
  * test decompress/2 decompresses rapidly changing values [L#93]  * test decompress/2 decompresses rapidly changing values (0.00ms) [L#93]
  * test validate_bitstream/2 detects count mismatch [L#197]  * test validate_bitstream/2 detects count mismatch (0.00ms) [L#197]
  * test decompress/2 handles large values [L#118]  * test decompress/2 handles large values (0.00ms) [L#118]
  * test edge cases and error conditions handles new window with invalid length [L#512]  * test edge cases and error conditions handles new window with invalid length (0.00ms) [L#512]
  * test decompress/2 decompresses multiple different values [L#28]  * test decompress/2 decompresses multiple different values (0.00ms) [L#28]
  * test edge cases and error conditions handles malformed XOR control bits [L#488]  * test edge cases and error conditions handles malformed XOR control bits (0.00ms) [L#488]
  * test decompress/2 decompresses negative values [L#44]  * test decompress/2 decompresses negative values (0.00ms) [L#44]
  * test validate_bitstream/2 rejects non-integer count [L#219]  * test validate_bitstream/2 rejects non-integer count (0.6ms) [L#219]
  * test edge cases and error conditions handles new window with negative trailing zeros [L#534]  * test edge cases and error conditions handles new window with negative trailing zeros (0.00ms) [L#534]
  * test edge cases and error conditions handles zero meaningful length in previous window [L#566]  * test edge cases and error conditions handles zero meaningful length in previous window (0.00ms) [L#566]
  * test decompress/2 decompresses repeated pattern [L#101]  * test decompress/2 decompresses repeated pattern (0.00ms) [L#101]
  * test decompress_and_validate/3 validates minimum values constraint [L#423]  * test decompress_and_validate/3 validates minimum values constraint (0.00ms) [L#423]
  * test round-trip consistency handles edge case values correctly [L#300]  * test round-trip consistency handles edge case values correctly (0.00ms) [L#300]
  * test edge cases and error conditions validates bitstream with wrong expected count edge cases [L#624]  * test edge cases and error conditions validates bitstream with wrong expected count edge cases (0.6ms) [L#624]
  * test validate_bitstream/2 rejects non-bitstring input [L#214]  * test validate_bitstream/2 rejects non-bitstring input (0.00ms) [L#214]
  * test decompress_and_validate/3 handles empty values validation [L#438]  * test decompress_and_validate/3 handles empty values validation (0.00ms) [L#438]
  * test decompress/2 decompresses slowly changing time series [L#84]  * test decompress/2 decompresses slowly changing time series (0.00ms) [L#84]
  * test get_bitstream_info/2 rejects non-map metadata [L#271]  * test get_bitstream_info/2 rejects non-map metadata (0.4ms) [L#271]
  * test edge cases and error conditions handles integer values in metadata conversion [L#613]  * test edge cases and error conditions handles integer values in metadata conversion (0.00ms) [L#613]
  * test edge cases and error conditions statistics calculation handles edge cases [L#658]  * test edge cases and error conditions statistics calculation handles edge cases (0.00ms) [L#658]
  * test edge cases and error conditions get_bitstream_info handles edge cases [L#640]  * test edge cases and error conditions get_bitstream_info handles edge cases (0.00ms) [L#640]
  * test get_bitstream_info/2 returns info for single value [L#234]  * test get_bitstream_info/2 returns info for single value (0.00ms) [L#234]
  * test decompress_and_validate/3 validates with max range constraint [L#407]  * test decompress_and_validate/3 validates with max range constraint (0.5ms) [L#407]
  * test decompress_and_validate/3 combines multiple validation criteria [L#465]  * test decompress_and_validate/3 combines multiple validation criteria (0.00ms) [L#465]
  * test round-trip consistency preserves order of values [L#329]  * test round-trip consistency preserves order of values (0.01ms) [L#329]
  * test validate_bitstream/2 handles invalid bitstream [L#207]  * test validate_bitstream/2 handles invalid bitstream (0.00ms) [L#207]
  * test decompress/2 decompresses mixed positive and negative values [L#52]  * test decompress/2 decompresses mixed positive and negative values (0.00ms) [L#52]
  * test edge cases and error conditions handles bitstream with only control bits [L#589]  * test edge cases and error conditions handles bitstream with only control bits (0.00ms) [L#589]
  * test compression efficiency scenarios handles alternating pattern [L#362]  * test compression efficiency scenarios handles alternating pattern (0.01ms) [L#362]
  * test error conditions handles insufficient data for single value [L#140]  * test error conditions handles insufficient data for single value (0.00ms) [L#140]
  * test round-trip consistency maintains precision across compress/decompress cycle [L#280]  * test round-trip consistency maintains precision across compress/decompress cycle (0.00ms) [L#280]
  * test get_bitstream_info/2 handles insufficient data [L#257]  * test get_bitstream_info/2 handles insufficient data (0.00ms) [L#257]
  * test decompress_and_validate/3 detects non-finite values [L#454]  * test decompress_and_validate/3 detects non-finite values (0.00ms) [L#454]
  * test edge cases and error conditions handles truncated new window header [L#554]  * test edge cases and error conditions handles truncated new window header (0.00ms) [L#554]
  * test get_bitstream_info/2 handles invalid input gracefully [L#252]  * test get_bitstream_info/2 handles invalid input gracefully (0.00ms) [L#252]
  * test decompress/2 decompresses single value [L#12]  * test decompress/2 decompresses single value (0.00ms) [L#12]
  * test decompress/2 decompresses two identical values [L#20]  * test decompress/2 decompresses two identical values (0.00ms) [L#20]
  * test error conditions handles corrupted XOR bitstream [L#158]  * test error conditions handles corrupted XOR bitstream (0.00ms) [L#158]
  * test edge cases and error conditions handles XOR bitstream with insufficient meaningful bits [L#501]  * test edge cases and error conditions handles XOR bitstream with insufficient meaningful bits (0.00ms) [L#501]
  * test decompress/2 decompresses floating-point values with high precision [L#36]  * test decompress/2 decompresses floating-point values with high precision (0.00ms) [L#36]
  * test decompress/2 decompresses very small values [L#60]  * test decompress/2 decompresses very small values (0.00ms) [L#60]
  * test compression efficiency scenarios handles highly compressible data [L#340]  * test compression efficiency scenarios handles highly compressible data (0.01ms) [L#340]
  * test validate_bitstream/2 validates correct bitstream [L#190]  * test validate_bitstream/2 validates correct bitstream (0.00ms) [L#190]
  * test edge cases and error conditions handles very long sequences [L#675]  * test edge cases and error conditions handles very long sequences (0.1ms) [L#675]
  * test edge cases and error conditions handles insufficient bits for control sequence [L#600]  * test edge cases and error conditions handles insufficient bits for control sequence (0.00ms) [L#600]
  * test error conditions returns error for invalid input types [L#130]  * test error conditions returns error for invalid input types (0.00ms) [L#130]
  * test error conditions handles insufficient data for first value in multiple values [L#149]  * test error conditions handles insufficient data for first value in multiple values (0.00ms) [L#149]
  * test decompress/2 decompresses zero values [L#76]  * test decompress/2 decompresses zero values (0.00ms) [L#76]
  * test decompress/2 decompresses very large values [L#68]  * test decompress/2 decompresses very large values (0.00ms) [L#68]

GorillaStream.Compression.Gorilla.DecoderTest [test/gorilla_stream/compression/gorilla/decoder_test.exs]
  * test estimate_decompression_performance/1 estimates performance for empty data [L#532]  * test estimate_decompression_performance/1 estimates performance for empty data (0.00ms) [L#532]
  * test validate_compressed_data/1 validates empty data [L#234]  * test validate_compressed_data/1 validates empty data (0.00ms) [L#234]
  * test estimate_decompression_performance/1 estimates performance for basic data [L#516]  * test estimate_decompression_performance/1 estimates performance for basic data (0.01ms) [L#516]
  * test get_compression_info/1 extracts info from empty data [L#317]  * test get_compression_info/1 extracts info from empty data (0.00ms) [L#317]
  * test decode/1 handles empty data [L#6]  * test decode/1 handles empty data (0.00ms) [L#6]
  * test validate_compressed_data/1 validates single point data [L#244]  * test validate_compressed_data/1 validates single point data (0.00ms) [L#244]
  * test get_compression_info/1 extracts info from large dataset [L#334]  * test get_compression_info/1 extracts info from large dataset (0.03ms) [L#334]
  * test decode/1 rejects non-binary input [L#165]  * test decode/1 rejects non-binary input (0.00ms) [L#165]

  5) test decode/1 rejects non-binary input (GorillaStream.Compression.Gorilla.DecoderTest)
     test/gorilla_stream/compression/gorilla/decoder_test.exs:165
     match (=) failed
     code:  assert {:ok, []} = Decoder.decode("not_binary")
     left:  {:ok, []}
     right: {:error, "Timestamp decoding failed: Invalid input - expected bitstring and metadata"}
     stacktrace:
       test/gorilla_stream/compression/gorilla/decoder_test.exs:169: (test)

  * test decode_and_validate/2 handles empty data validation [L#480]  * test decode_and_validate/2 handles empty data validation (0.00ms) [L#480]
  * test decode/1 decodes maximum timestamp values [L#144]  * test decode/1 decodes maximum timestamp values (0.01ms) [L#144]
  * test validate_compressed_data/1 rejects invalid binary data [L#260]  * test validate_compressed_data/1 rejects invalid binary data (0.00ms) [L#260]
  * test decode/1 handles corrupted metadata gracefully [L#172]  * test decode/1 handles corrupted metadata gracefully (0.00ms) [L#172]

  6) test decode/1 handles corrupted metadata gracefully (GorillaStream.Compression.Gorilla.DecoderTest)
     test/gorilla_stream/compression/gorilla/decoder_test.exs:172
     match (=) failed
     code:  assert {:ok, []} = Decoder.decode(corrupted_data)
     left:  {:ok, []}
     right: {:error, "Timestamp decoding failed: Invalid input - expected bitstring and metadata"}
     stacktrace:
       test/gorilla_stream/compression/gorilla/decoder_test.exs:182: (test)

  * test edge cases for improved coverage decodes data with large timestamp values [L#639]  * test edge cases for improved coverage decodes data with large timestamp values (0.00ms) [L#639]
  * test decode/1 decodes data with integer values [L#35]  * test decode/1 decodes data with integer values (0.01ms) [L#35]
  * test edge cases for improved coverage handles malformed binary data [L#621]  * test edge cases for improved coverage handles malformed binary data (0.00ms) [L#621]

  7) test edge cases for improved coverage handles malformed binary data (GorillaStream.Compression.Gorilla.DecoderTest)
     test/gorilla_stream/compression/gorilla/decoder_test.exs:621
     match (=) failed
     code:  assert {:ok, []} = result
     left:  {:ok, []}
     right: {:error, "Timestamp decoding failed: Invalid input - expected bitstring and metadata"}
     stacktrace:
       test/gorilla_stream/compression/gorilla/decoder_test.exs:627: (test)

  * test decode/1 decodes slowly changing values [L#67]  * test decode/1 decodes slowly changing values (0.00ms) [L#67]
  * test get_compression_info/1 extracts info from properly encoded data [L#300]  * test get_compression_info/1 extracts info from properly encoded data (0.00ms) [L#300]
  * test edge cases for improved coverage decodes data with extreme float values [L#651]  * test edge cases for improved coverage decodes data with extreme float values (0.00ms) [L#651]
  * test edge cases and robustness handles maximum timestamp values safely [L#966]  * test edge cases and robustness handles maximum timestamp values safely (0.00ms) [L#966]
  * test edge cases for improved coverage decodes data with identical consecutive values [L#678]  * test edge cases for improved coverage decodes data with identical consecutive values (0.00ms) [L#678]
  * test decode/1 handles invalid binary data gracefully [L#159]  * test decode/1 handles invalid binary data gracefully (0.00ms) [L#159]

  8) test decode/1 handles invalid binary data gracefully (GorillaStream.Compression.Gorilla.DecoderTest)
     test/gorilla_stream/compression/gorilla/decoder_test.exs:159
     match (=) failed
     code:  assert {:ok, []} = Decoder.decode(invalid_data)
     left:  {:ok, []}
     right: {:error, "Timestamp decoding failed: Invalid input - expected bitstring and metadata"}
     stacktrace:
       test/gorilla_stream/compression/gorilla/decoder_test.exs:162: (test)

  * test estimate_decompression_performance/1 handles invalid data [L#554]  * test estimate_decompression_performance/1 handles invalid data (0.00ms) [L#554]
  * test decode_and_validate/2 validates timestamp range [L#412]  * test decode_and_validate/2 validates timestamp range (0.00ms) [L#412]
  * test edge cases and robustness handles very small datasets gracefully [L#994]  * test edge cases and robustness handles very small datasets gracefully (0.01ms) [L#994]
  * test edge cases for improved coverage decodes data with zero values [L#736]  * test edge cases for improved coverage decodes data with zero values (0.00ms) [L#736]
  * test validate_compressed_data/1 handles non-binary input [L#282]  * test validate_compressed_data/1 handles non-binary input (0.00ms) [L#282]
  * test estimate_decompression_performance/1 handles non-binary input [L#567]  * test estimate_decompression_performance/1 handles non-binary input (0.00ms) [L#567]
  * test decode/1 decodes alternating patterns [L#130]  * test decode/1 decodes alternating patterns (0.00ms) [L#130]
  * test decode_and_validate/2 decodes and validates basic data [L#375]  * test decode_and_validate/2 decodes and validates basic data (0.00ms) [L#375]
  * test edge cases for improved coverage decodes very large dataset [L#724]  * test edge cases for improved coverage decodes very large dataset (0.08ms) [L#724]
  * test edge cases for improved coverage handles empty encoded data properly [L#767]  * test edge cases for improved coverage handles empty encoded data properly (0.00ms) [L#767]
  * test edge cases for improved coverage decodes data with mixed positive and negative values [L#754]  * test edge cases for improved coverage decodes data with mixed positive and negative values (0.00ms) [L#754]
  * test get_compression_info/1 extracts info from single point [L#325]  * test get_compression_info/1 extracts info from single point (0.00ms) [L#325]
  * test edge cases for improved coverage error handling in complete pipeline [L#887]  * test edge cases for improved coverage error handling in complete pipeline (0.00ms) [L#887]
  * test edge cases for improved coverage handles realistic sensor data [L#862]  * test edge cases for improved coverage handles realistic sensor data (0.04ms) [L#862]
  * test estimate_decompression_performance/1 estimates performance for large dataset [L#540]  * test estimate_decompression_performance/1 estimates performance for large dataset (0.05ms) [L#540]
  * test integration and round-trip tests consistency across multiple encode/decode cycles [L#601]  * test integration and round-trip tests consistency across multiple encode/decode cycles (0.01ms) [L#601]
  * test decode_and_validate/2 validates value range [L#432]  * test decode_and_validate/2 validates value range (0.00ms) [L#432]
  * test validate_compressed_data/1 handles truncated data validation [L#266]  * test validate_compressed_data/1 handles truncated data validation (0.00ms) [L#266]
  * test decode/1 decodes irregular timestamp intervals [L#81]  * test decode/1 decodes irregular timestamp intervals (0.00ms) [L#81]
  * test edge cases for improved coverage decodes data with irregular timestamp intervals [L#691]  * test edge cases for improved coverage decodes data with irregular timestamp intervals (0.00ms) [L#691]
  * test decode_and_validate/2 combines multiple validation criteria [L#486]  * test decode_and_validate/2 combines multiple validation criteria (0.00ms) [L#486]
  * test decode/1 handles floating point precision [L#197]  * test decode/1 handles floating point precision (0.00ms) [L#197]
  * test decode_and_validate/2 validates with expected count [L#393]  * test decode_and_validate/2 validates with expected count (0.00ms) [L#393]
  * test get_compression_info/1 handles non-binary input [L#362]  * test get_compression_info/1 handles non-binary input (0.00ms) [L#362]
  * test integration and round-trip tests perfect round-trip with various data patterns [L#580]  * test integration and round-trip tests perfect round-trip with various data patterns (0.04ms) [L#580]
  * test edge cases for improved coverage decodes data with decreasing timestamps [L#666]  * test edge cases for improved coverage decodes data with decreasing timestamps (0.00ms) [L#666]
  * test edge cases and robustness handles zero and negative timestamps [L#954]  * test edge cases and robustness handles zero and negative timestamps (0.00ms) [L#954]
  * test get_compression_info/1 handles invalid data [L#349]  * test get_compression_info/1 handles invalid data (0.00ms) [L#349]
  * test edge cases and robustness validation with edge case values [L#980]  * test edge cases and robustness validation with edge case values (0.00ms) [L#980]
  * test decode/1 decodes single data point [L#10]  * test decode/1 decodes single data point (0.00ms) [L#10]
  * test decode/1 decodes multiple data points with regular timestamps [L#21]  * test decode/1 decodes multiple data points with regular timestamps (0.00ms) [L#21]
  * test validate_compressed_data/1 validates properly encoded data [L#223]  * test validate_compressed_data/1 validates properly encoded data (0.00ms) [L#223]
  * test edge cases for improved coverage handles binary with insufficient data [L#630]  * test edge cases for improved coverage handles binary with insufficient data (0.00ms) [L#630]

  9) test edge cases for improved coverage handles binary with insufficient data (GorillaStream.Compression.Gorilla.DecoderTest)
     test/gorilla_stream/compression/gorilla/decoder_test.exs:630
     match (=) failed
     code:  assert {:ok, []} = result
     left:  {:ok, []}
     right: {:error, "Timestamp decoding failed: Invalid input - expected bitstring and metadata"}
     stacktrace:
       test/gorilla_stream/compression/gorilla/decoder_test.exs:636: (test)

  * test decode/1 decodes identical consecutive values [L#54]  * test decode/1 decodes identical consecutive values (0.00ms) [L#54]
  * test decode/1 decodes negative values [L#94]  * test decode/1 decodes negative values (0.00ms) [L#94]
  * test decode_and_validate/2 validates timestamp bounds [L#452]  * test decode_and_validate/2 validates timestamp bounds (0.01ms) [L#452]
  * test edge cases for improved coverage memory efficiency on large datasets [L#934]  * test edge cases for improved coverage memory efficiency on large datasets (1.3ms) [L#934]
  * test validate_compressed_data/1 validates large datasets [L#250]  * test validate_compressed_data/1 validates large datasets (0.05ms) [L#250]
  * test edge cases for improved coverage returns bit unpacking error for corrupted data body [L#776]  * test edge cases for improved coverage returns bit unpacking error for corrupted data body (0.00ms) [L#776]
  * test edge cases for improved coverage decodes data with special float values [L#709]  * test edge cases for improved coverage decodes data with special float values (0.00ms) [L#709]
  * test decode/1 handles truncated data [L#185]  * test decode/1 handles truncated data (0.00ms) [L#185]

 10) test decode/1 handles truncated data (GorillaStream.Compression.Gorilla.DecoderTest)
     test/gorilla_stream/compression/gorilla/decoder_test.exs:185
     match (=) failed
     code:  assert {:ok, []} = Decoder.decode(truncated_data)
     left:  {:ok, []}
     right: {:error, "Timestamp decoding failed: Invalid input - expected bitstring and metadata"}
     stacktrace:
       test/gorilla_stream/compression/gorilla/decoder_test.exs:194: (test)

  * test decode/1 decodes subnormal float values [L#209]  * test decode/1 decodes subnormal float values (0.00ms) [L#209]
  * test decode/1 decodes large datasets [L#118]  * test decode/1 decodes large datasets (0.04ms) [L#118]
  * test edge cases for improved coverage returns timestamp decoding error for corrupted timestamp data [L#818]  * test edge cases for improved coverage returns timestamp decoding error for corrupted timestamp data (0.00ms) [L#818]
  * test decode/1 decodes extreme float values [L#106]  * test decode/1 decodes extreme float values (0.00ms) [L#106]

GorillaStream.Compression.Encoder.ValueCompressionTest [test/gorilla_stream/compression/encoder/value_compression_test.exs]
  * test edge cases for uncovered code paths handles encode_xor_result window reuse with exact boundary conditions [L#596]  * test edge cases for uncovered code paths handles encode_xor_result window reuse with exact boundary conditions (0.00ms) [L#596]
  * test compress/1 handles infinity and NaN values [L#251]  * test compress/1 handles infinity and NaN values (0.00ms) [L#251]
  * test edge cases for uncovered code paths handles count_trailing_zeros with maximum count [L#583]  * test edge cases for uncovered code paths handles count_trailing_zeros with maximum count (0.00ms) [L#583]
  * test integration with actual float patterns compresses typical sensor data pattern [L#354]  * test integration with actual float patterns compresses typical sensor data pattern (0.00ms) [L#354]
  * test compress/1 handles empty list [L#6]  * test compress/1 handles empty list (0.00ms) [L#6]
  * test compress/1 compresses time series with trend [L#265]  * test compress/1 compresses time series with trend (0.00ms) [L#265]
  * test integration with actual float patterns compresses metrics with periodic pattern [L#410]  * test integration with actual float patterns compresses metrics with periodic pattern (0.00ms) [L#410]
  * test compress/1 compresses zero and near-zero values [L#169]  * test compress/1 compresses zero and near-zero values (0.00ms) [L#169]
  * test edge cases for uncovered code paths handles encode_new_window with meaningful_value calculation edge case [L#550]  * test edge cases for uncovered code paths handles encode_new_window with meaningful_value calculation edge case (0.00ms) [L#550]
  * test compress/1 compresses values with identical mantissa but different exponent [L#148]  * test compress/1 compresses values with identical mantissa but different exponent (0.00ms) [L#148]
  * test compress/1 compresses oscillating values [L#299]  * test compress/1 compresses oscillating values (0.00ms) [L#299]
  * test compress/1 handles mixed positive and negative values with small differences [L#178]  * test compress/1 handles mixed positive and negative values with small differences (0.00ms) [L#178]
  * test targeted coverage for specific uncovered paths covers encode_new_window with meaningful_bits boundary adjustments [L#732]  * test targeted coverage for specific uncovered paths covers encode_new_window with meaningful_bits boundary adjustments (0.00ms) [L#732]
  * test compress/1 compresses identical consecutive values efficiently [L#41]  * test compress/1 compresses identical consecutive values efficiently (0.00ms) [L#41]
  * test targeted coverage for specific uncovered paths covers count_leading_zeros edge case with exactly 64 leading zeros [L#706]  * test targeted coverage for specific uncovered paths covers count_leading_zeros edge case with exactly 64 leading zeros (0.00ms) [L#706]
  * test compress/1 handles values requiring new window encoding [L#75]  * test compress/1 handles values requiring new window encoding (0.00ms) [L#75]
  * test compress/1 handles step function pattern [L#339]  * test compress/1 handles step function pattern (0.00ms) [L#339]
  * test targeted coverage for specific uncovered paths covers meaningful_length == 0 fallback path in encode_xor_result [L#752]  * test targeted coverage for specific uncovered paths covers meaningful_length == 0 fallback path in encode_xor_result (0.00ms) [L#752]
  * test precision-targeted coverage for uncovered paths hits adjusted_meaningful_bits = max(1, min(64, meaningful_bits)) [L#1023]  * test precision-targeted coverage for uncovered paths hits adjusted_meaningful_bits = max(1, min(64, meaningful_bits)) (0.00ms) [L#1023]
  * test targeted coverage for specific uncovered paths covers count_trailing_zeros recursive boundary when count reaches 64 [L#783]  * test targeted coverage for specific uncovered paths covers count_trailing_zeros recursive boundary when count reaches 64 (0.00ms) [L#783]
  * test compress/1 handles subnormal numbers [L#158]  * test compress/1 handles subnormal numbers (0.00ms) [L#158]
  * test edge cases for uncovered code paths handles mixed integer and float values [L#634]  * test edge cases for uncovered code paths handles mixed integer and float values (0.00ms) [L#634]
  * test edge cases for uncovered code paths handles count_leading_zeros with value at bit 63 [L#495]  * test edge cases for uncovered code paths handles count_leading_zeros with value at bit 63 (0.00ms) [L#495]
  * test precision-targeted coverage for uncovered paths hits meaningful_value calculation when adjusted_meaningful_bits > 0 [L#1064]  * test precision-targeted coverage for uncovered paths hits meaningful_value calculation when adjusted_meaningful_bits > 0 (0.00ms) [L#1064]
  * test targeted coverage for specific uncovered paths covers encode_new_window with adjusted_leading_zeros boundary [L#840]  * test targeted coverage for specific uncovered paths covers encode_new_window with adjusted_leading_zeros boundary (0.00ms) [L#840]
  * test compress/1 compresses power-of-2 values efficiently [L#328]  * test compress/1 compresses power-of-2 values efficiently (0.00ms) [L#328]
  * test edge cases for uncovered code paths exercises all branches of count_leading_zeros recursion [L#645]  * test edge cases for uncovered code paths exercises all branches of count_leading_zeros recursion (0.00ms) [L#645]
  * test compress/1 compresses alternating pattern [L#136]  * test compress/1 compresses alternating pattern (0.00ms) [L#136]
  * test edge cases and error conditions handles mixed finite and infinite values [L#463]  * test edge cases and error conditions handles mixed finite and infinite values (0.00ms) [L#463]
  * test targeted coverage for specific uncovered paths covers encode_xor_result window reuse false branch [L#821]  * test targeted coverage for specific uncovered paths covers encode_xor_result window reuse false branch (0.00ms) [L#821]
  * test targeted coverage for specific uncovered paths covers all branches in count_trailing_zeros with different bit patterns [L#876]  * test targeted coverage for specific uncovered paths covers all branches in count_trailing_zeros with different bit patterns (0.00ms) [L#876]
  * test targeted coverage for specific uncovered paths covers all branches in count_leading_zeros with different bit patterns [L#856]  * test targeted coverage for specific uncovered paths covers all branches in count_leading_zeros with different bit patterns (0.00ms) [L#856]
  * test integration with actual float patterns handles financial data pattern [L#389]  * test integration with actual float patterns handles financial data pattern (0.00ms) [L#389]
  * test precision-targeted coverage for uncovered paths forces meaningful_length = 0 fallback with precise bit patterns [L#958]  * test precision-targeted coverage for uncovered paths forces meaningful_length = 0 fallback with precise bit patterns (0.00ms) [L#958]
  * test targeted coverage for specific uncovered paths covers specific bitwise operations in encode_new_window [L#938]  * test targeted coverage for specific uncovered paths covers specific bitwise operations in encode_new_window (0.00ms) [L#938]
  * test edge cases for uncovered code paths handles integer to float conversion edge case [L#622]  * test edge cases for uncovered code paths handles integer to float conversion edge case (0.00ms) [L#622]
  * test edge cases for uncovered code paths forces encode_new_window path when reuse conditions not met [L#682]  * test edge cases for uncovered code paths forces encode_new_window path when reuse conditions not met (0.00ms) [L#682]
  * test edge cases for uncovered code paths handles count_trailing_zeros boundary conditions [L#514]  * test edge cases for uncovered code paths handles count_trailing_zeros boundary conditions (0.00ms) [L#514]
  * test compress/1 handles edge case with very small differences [L#313]  * test compress/1 handles edge case with very small differences (0.00ms) [L#313]
  * test compress/1 compresses IEEE 754 special values [L#91]  * test compress/1 compresses IEEE 754 special values (0.00ms) [L#91]
  * test precision-targeted coverage for uncovered paths complex alternating sequence of reuse and new window [L#1142]  * test precision-targeted coverage for uncovered paths complex alternating sequence of reuse and new window (0.00ms) [L#1142]
  * test targeted coverage for specific uncovered paths covers encode_new_window meaningful_value calculation when adjusted_meaningful_bits > 0 [L#793]  * test targeted coverage for specific uncovered paths covers encode_new_window meaningful_value calculation when adjusted_meaningful_bits > 0 (0.00ms) [L#793]
  * test edge cases for uncovered code paths handles count_leading_zeros with maximum count [L#569]  * test edge cases for uncovered code paths handles count_leading_zeros with maximum count (0.00ms) [L#569]
  * test compress/1 handles random-like values [L#208]  * test compress/1 handles random-like values (0.00ms) [L#208]
  * test edge cases for uncovered code paths handles meaningful_length == 0 fallback in encode_xor_result [L#477]  * test edge cases for uncovered code paths handles meaningful_length == 0 fallback in encode_xor_result (0.00ms) [L#477]
  * test edge cases and error conditions compresses values at float precision limits [L#445]  * test edge cases and error conditions compresses values at float precision limits (0.01ms) [L#445]
  * test edge cases for uncovered code paths exercises all branches of count_trailing_zeros recursion [L#663]  * test edge cases for uncovered code paths exercises all branches of count_trailing_zeros recursion (0.00ms) [L#663]
  * test targeted coverage for specific uncovered paths covers count_leading_zeros recursive boundary when count reaches 64 [L#772]  * test targeted coverage for specific uncovered paths covers count_leading_zeros recursive boundary when count reaches 64 (0.00ms) [L#772]
  * test precision-targeted coverage for uncovered paths hits count_trailing_zeros guard clause with (value &&& 1) != 0 [L#1000]  * test precision-targeted coverage for uncovered paths hits count_trailing_zeros guard clause with (value &&& 1) != 0 (0.00ms) [L#1000]
  * test edge cases and error conditions handles list with only zeros [L#434]  * test edge cases and error conditions handles list with only zeros (0.00ms) [L#434]
  * test precision-targeted coverage for uncovered paths hits adjusted_leading_zeros = max(0, min(31, leading_zeros)) [L#1043]  * test precision-targeted coverage for uncovered paths hits adjusted_leading_zeros = max(0, min(31, leading_zeros)) (0.00ms) [L#1043]
  * test compress/1 handles single value [L#13]  * test compress/1 handles single value (0.00ms) [L#13]
  * test compress/1 handles single integer value [L#27]  * test compress/1 handles single integer value (0.00ms) [L#27]
  * test precision-targeted coverage for uncovered paths hits the else clause in meaningful_value calculation [L#1083]  * test precision-targeted coverage for uncovered paths hits the else clause in meaningful_value calculation (0.00ms) [L#1083]
  * test compress/1 compresses geometric sequence [L#241]  * test compress/1 compresses geometric sequence (0.00ms) [L#241]
  * test targeted coverage for specific uncovered paths covers count_trailing_zeros edge case with exactly 64 trailing zeros [L#719]  * test targeted coverage for specific uncovered paths covers count_trailing_zeros edge case with exactly 64 trailing zeros (0.00ms) [L#719]
  * test compress/1 compresses slowly changing values using window reuse [L#58]  * test compress/1 compresses slowly changing values using window reuse (0.00ms) [L#58]
  * test compress/1 handles negative values [L#100]  * test compress/1 handles negative values (0.00ms) [L#100]
  * test edge cases for uncovered code paths handles encode_new_window with adjusted_meaningful_bits at boundaries [L#530]  * test edge cases for uncovered code paths handles encode_new_window with adjusted_meaningful_bits at boundaries (0.00ms) [L#530]
  * test precision-targeted coverage for uncovered paths hits count_leading_zeros guard clause with (value &&& 1 <<< 63) != 0 [L#988]  * test precision-targeted coverage for uncovered paths hits count_leading_zeros guard clause with (value &&& 1 <<< 63) != 0 (0.00ms) [L#988]
  * test compress/1 maintains precision for round-trip compatibility [L#278]  * test compress/1 maintains precision for round-trip compatibility (0.00ms) [L#278]
  * test targeted coverage for specific uncovered paths covers encode_xor_result meaningful_bits == 0 edge case [L#897]  * test targeted coverage for specific uncovered paths covers encode_xor_result meaningful_bits == 0 edge case (0.00ms) [L#897]
  * test targeted coverage for specific uncovered paths covers float_to_bits with integer conversion branch [L#810]  * test targeted coverage for specific uncovered paths covers float_to_bits with integer conversion branch (0.00ms) [L#810]
  * test compress/1 compresses values with high precision [L#188]  * test compress/1 compresses values with high precision (0.00ms) [L#188]
  * test compress/1 efficiently compresses long sequence of identical values [L#228]  * test compress/1 efficiently compresses long sequence of identical values (0.02ms) [L#228]
  * test compress/1 handles extreme float values [L#123]  * test compress/1 handles extreme float values (0.00ms) [L#123]
  * test surgical strike for 90% coverage hits the meaningful_length == 0 fallback branch in encode_xor_result [L#1190]  * test surgical strike for 90% coverage hits the meaningful_length == 0 fallback branch in encode_xor_result (0.00ms) [L#1190]
  * test targeted coverage for specific uncovered paths covers encode_new_window with maximum meaningful_bits [L#920]  * test targeted coverage for specific uncovered paths covers encode_new_window with maximum meaningful_bits (0.00ms) [L#920]
  * test compress/1 compresses gradual increases efficiently [L#109]  * test compress/1 compresses gradual increases efficiently (0.00ms) [L#109]

GorillaStream.Performance.StressTest [test/performance/stress_test.exs]
  * test stress testing memory leak detection with repeated operations [L#7]Iteration 10: Memory growth: -7064656 bytes
Iteration 20: Memory growth: -7072672 bytes
Iteration 30: Memory growth: -7072568 bytes
Iteration 40: Memory growth: -7072328 bytes
Iteration 50: Memory growth: -7088368 bytes
Iteration 60: Memory growth: -7088264 bytes
Iteration 70: Memory growth: -7063992 bytes
Iteration 80: Memory growth: -7080032 bytes
Iteration 90: Memory growth: -7087952 bytes
Iteration 100: Memory growth: -7063680 bytes

=== Memory Leak Test Results ===
Initial memory: 62373637 bytes
Final memory: 55225669 bytes
Total growth: -7147968 bytes
Growth per iteration: -71479.68 bytes
  * test stress testing memory leak detection with repeated operations (120.7ms) [L#7]
  * test stress testing error resilience under stress [L#155]
--- Testing massive_invalid_data ---
massive_invalid_data: 0 success, 13 errors out of 13

--- Testing corrupted_compressed_data ---
corrupted_compressed_data: 3 success, 6 errors out of 9

--- Testing boundary_value_stress ---
boundary_value_stress: 8 success, 0 errors out of 8

--- Testing malformed_input_stress ---
malformed_input_stress: 2 success, 3 errors out of 5
Error resilience test completed - system remained stable
  * test stress testing error resilience under stress (16.4ms) [L#155]
  * test stress testing large dataset processing (1M+ points) [L#53]
=== Large Dataset Test (1M points) ===
Generated 1000000 data points
Compression time: 0.53 seconds
Compressed size: 8375121 bytes
Compression ratio: 0.5234

BREAK: (a)bort (A)bort with dump (c)ontinue (p)roc info (i)nfo
       (l)oaded (v)ersion (k)ill (D)b-tables (d)istribution
